package main

//go:generate go run .
//go:generate go run github.com/tinylib/msgp -tests=false -o=../msgp.go -file=..

import (
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/diamondburned/cchat/repository"
)

var knownPaths = map[string]struct{}{}

func pathIsKnown(path string) bool {
	_, ok := knownPaths[path]
	return ok
}

const IPCCore = "github.com/diamondburned/cchat-ipc/go/internal/ipc/core"

func main() {
	guaranteePurity(repository.Main)

	for pkgPath := range repository.Main {
		knownPaths[pkgPath] = struct{}{}
	}

	f := jen.NewFile("messages")
	f.HeaderComment("Code generated by ./_generator. DO NOT EDIT.")
	f.ImportName(IPCCore, "core")
	f.ImportName("github.com/diamondburned/cchat", "cchat")
	f.ImportName("github.com/diamondburned/cchat/text", "text")

	gen := Generator{file: f}

	for pkgPath, pkg := range repository.Main {
		gen.pkg = pkg
		gen.path = pkgPath
		gen.prefix = ""

		if pkgPath != repository.RootPath {
			gen.prefix = pathPrefix(pkgPath)
		}

		gen.genTypes()
	}

	goFile, err := os.Create(filepath.Join("..", "generated.go"))
	if err != nil {
		log.Fatalln("Failed to create output file:", err)
	}

	if err := f.Render(goFile); err != nil {
		log.Fatalln("Failed to render output:", err)
	}

	goFile.Close()
}

func pathPrefix(typePath string) string {
	return strings.Title(path.Base(typePath))
}
