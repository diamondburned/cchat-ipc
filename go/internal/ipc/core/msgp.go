package core

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *Call) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "oid":
			{
				var zb0002 uint64
				zb0002, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "InstanceID")
					return
				}
				z.InstanceID = InstanceID(zb0002)
			}
		case "cid":
			{
				var zb0003 uint64
				zb0003, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "CallID")
					return
				}
				z.CallID = CallID(zb0003)
			}
		case "mp":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "MethodPath")
				return
			}
			if cap(z.MethodPath) >= int(zb0004) {
				z.MethodPath = (z.MethodPath)[:zb0004]
			} else {
				z.MethodPath = make(MethodPath, zb0004)
			}
			for za0001 := range z.MethodPath {
				{
					var zb0005 uint8
					zb0005, err = dc.ReadUint8()
					if err != nil {
						err = msgp.WrapError(err, "MethodPath", za0001)
						return
					}
					z.MethodPath[za0001] = MethodID(zb0005)
				}
			}
		case "p":
			err = z.Parameters.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Parameters")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Call) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 4 bits */
	if z.CallID == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	// write "oid"
	err = en.Append(0xa3, 0x6f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(uint64(z.InstanceID))
	if err != nil {
		err = msgp.WrapError(err, "InstanceID")
		return
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "cid"
		err = en.Append(0xa3, 0x63, 0x69, 0x64)
		if err != nil {
			return
		}
		err = en.WriteUint64(uint64(z.CallID))
		if err != nil {
			err = msgp.WrapError(err, "CallID")
			return
		}
	}
	// write "mp"
	err = en.Append(0xa2, 0x6d, 0x70)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.MethodPath)))
	if err != nil {
		err = msgp.WrapError(err, "MethodPath")
		return
	}
	for za0001 := range z.MethodPath {
		err = en.WriteUint8(uint8(z.MethodPath[za0001]))
		if err != nil {
			err = msgp.WrapError(err, "MethodPath", za0001)
			return
		}
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = z.Parameters.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Parameters")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Call) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 4 bits */
	if z.CallID == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	// string "oid"
	o = append(o, 0xa3, 0x6f, 0x69, 0x64)
	o = msgp.AppendUint64(o, uint64(z.InstanceID))
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "cid"
		o = append(o, 0xa3, 0x63, 0x69, 0x64)
		o = msgp.AppendUint64(o, uint64(z.CallID))
	}
	// string "mp"
	o = append(o, 0xa2, 0x6d, 0x70)
	o = msgp.AppendArrayHeader(o, uint32(len(z.MethodPath)))
	for za0001 := range z.MethodPath {
		o = msgp.AppendUint8(o, uint8(z.MethodPath[za0001]))
	}
	// string "p"
	o = append(o, 0xa1, 0x70)
	o, err = z.Parameters.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Parameters")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Call) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "oid":
			{
				var zb0002 uint64
				zb0002, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "InstanceID")
					return
				}
				z.InstanceID = InstanceID(zb0002)
			}
		case "cid":
			{
				var zb0003 uint64
				zb0003, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CallID")
					return
				}
				z.CallID = CallID(zb0003)
			}
		case "mp":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MethodPath")
				return
			}
			if cap(z.MethodPath) >= int(zb0004) {
				z.MethodPath = (z.MethodPath)[:zb0004]
			} else {
				z.MethodPath = make(MethodPath, zb0004)
			}
			for za0001 := range z.MethodPath {
				{
					var zb0005 uint8
					zb0005, bts, err = msgp.ReadUint8Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "MethodPath", za0001)
						return
					}
					z.MethodPath[za0001] = MethodID(zb0005)
				}
			}
		case "p":
			bts, err = z.Parameters.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Parameters")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Call) Msgsize() (s int) {
	s = 1 + 4 + msgp.Uint64Size + 4 + msgp.Uint64Size + 3 + msgp.ArrayHeaderSize + (len(z.MethodPath) * (msgp.Uint8Size)) + 2 + z.Parameters.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CallID) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 uint64
		zb0001, err = dc.ReadUint64()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = CallID(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z CallID) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteUint64(uint64(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z CallID) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint64(o, uint64(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CallID) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint64
		zb0001, bts, err = msgp.ReadUint64Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = CallID(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z CallID) Msgsize() (s int) {
	s = msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CancelCall) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "cid":
			{
				var zb0002 uint64
				zb0002, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "CallID")
					return
				}
				z.CallID = CallID(zb0002)
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z CancelCall) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "cid"
	err = en.Append(0x81, 0xa3, 0x63, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(uint64(z.CallID))
	if err != nil {
		err = msgp.WrapError(err, "CallID")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z CancelCall) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "cid"
	o = append(o, 0x81, 0xa3, 0x63, 0x69, 0x64)
	o = msgp.AppendUint64(o, uint64(z.CallID))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CancelCall) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "cid":
			{
				var zb0002 uint64
				zb0002, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CallID")
					return
				}
				z.CallID = CallID(zb0002)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z CancelCall) Msgsize() (s int) {
	s = 1 + 4 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Error) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "t":
			{
				var zb0002 uint8
				zb0002, err = dc.ReadUint8()
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = ErrorType(zb0002)
			}
		case "d":
			err = z.Data.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Error) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "t"
	err = en.Append(0x82, 0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint8(uint8(z.Type))
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "d"
	err = en.Append(0xa1, 0x64)
	if err != nil {
		return
	}
	err = z.Data.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Error) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "t"
	o = append(o, 0x82, 0xa1, 0x74)
	o = msgp.AppendUint8(o, uint8(z.Type))
	// string "d"
	o = append(o, 0xa1, 0x64)
	o, err = z.Data.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Error) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "t":
			{
				var zb0002 uint8
				zb0002, bts, err = msgp.ReadUint8Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = ErrorType(zb0002)
			}
		case "d":
			bts, err = z.Data.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Error) Msgsize() (s int) {
	s = 1 + 2 + msgp.Uint8Size + 2 + z.Data.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ErrorType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 uint8
		zb0001, err = dc.ReadUint8()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = ErrorType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ErrorType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteUint8(uint8(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ErrorType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint8(o, uint8(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ErrorType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint8
		zb0001, bts, err = msgp.ReadUint8Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = ErrorType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ErrorType) Msgsize() (s int) {
	s = msgp.Uint8Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *File) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "filename":
			z.Filename, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Filename")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z File) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "filename"
	err = en.Append(0x81, 0xa8, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Filename)
	if err != nil {
		err = msgp.WrapError(err, "Filename")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z File) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "filename"
	o = append(o, 0x81, 0xa8, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Filename)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *File) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "filename":
			z.Filename, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Filename")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z File) Msgsize() (s int) {
	s = 1 + 9 + msgp.StringPrefixSize + len(z.Filename)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Instance) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			{
				var zb0002 uint64
				zb0002, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "ID")
					return
				}
				z.ID = InstanceID(zb0002)
			}
		case "typ":
			{
				var zb0003 uint16
				zb0003, err = dc.ReadUint16()
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = InstanceType(zb0003)
			}
		case "s":
			{
				var zb0004 uint64
				zb0004, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "StopHandle")
					return
				}
				z.StopHandle = StopHandle(zb0004)
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Instance) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	if z.ID == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.StopHandle == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "id"
		err = en.Append(0xa2, 0x69, 0x64)
		if err != nil {
			return
		}
		err = en.WriteUint64(uint64(z.ID))
		if err != nil {
			err = msgp.WrapError(err, "ID")
			return
		}
	}
	// write "typ"
	err = en.Append(0xa3, 0x74, 0x79, 0x70)
	if err != nil {
		return
	}
	err = en.WriteUint16(uint16(z.Type))
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "s"
		err = en.Append(0xa1, 0x73)
		if err != nil {
			return
		}
		err = en.WriteUint64(uint64(z.StopHandle))
		if err != nil {
			err = msgp.WrapError(err, "StopHandle")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Instance) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	if z.ID == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.StopHandle == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "id"
		o = append(o, 0xa2, 0x69, 0x64)
		o = msgp.AppendUint64(o, uint64(z.ID))
	}
	// string "typ"
	o = append(o, 0xa3, 0x74, 0x79, 0x70)
	o = msgp.AppendUint16(o, uint16(z.Type))
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "s"
		o = append(o, 0xa1, 0x73)
		o = msgp.AppendUint64(o, uint64(z.StopHandle))
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Instance) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			{
				var zb0002 uint64
				zb0002, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ID")
					return
				}
				z.ID = InstanceID(zb0002)
			}
		case "typ":
			{
				var zb0003 uint16
				zb0003, bts, err = msgp.ReadUint16Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = InstanceType(zb0003)
			}
		case "s":
			{
				var zb0004 uint64
				zb0004, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StopHandle")
					return
				}
				z.StopHandle = StopHandle(zb0004)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Instance) Msgsize() (s int) {
	s = 1 + 3 + msgp.Uint64Size + 4 + msgp.Uint16Size + 2 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *InstanceID) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 uint64
		zb0001, err = dc.ReadUint64()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = InstanceID(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z InstanceID) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteUint64(uint64(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z InstanceID) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint64(o, uint64(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *InstanceID) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint64
		zb0001, bts, err = msgp.ReadUint64Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = InstanceID(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z InstanceID) Msgsize() (s int) {
	s = msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *InstanceType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 uint16
		zb0001, err = dc.ReadUint16()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = InstanceType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z InstanceType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteUint16(uint16(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z InstanceType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint16(o, uint16(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *InstanceType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint16
		zb0001, bts, err = msgp.ReadUint16Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = InstanceType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z InstanceType) Msgsize() (s int) {
	s = msgp.Uint16Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MethodID) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 uint8
		zb0001, err = dc.ReadUint8()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MethodID(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z MethodID) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteUint8(uint8(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MethodID) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint8(o, uint8(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MethodID) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint8
		zb0001, bts, err = msgp.ReadUint8Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MethodID(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MethodID) Msgsize() (s int) {
	s = msgp.Uint8Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MethodPath) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(MethodPath, zb0002)
	}
	for zb0001 := range *z {
		{
			var zb0003 uint8
			zb0003, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			(*z)[zb0001] = MethodID(zb0003)
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z MethodPath) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0004 := range z {
		err = en.WriteUint8(uint8(z[zb0004]))
		if err != nil {
			err = msgp.WrapError(err, zb0004)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MethodPath) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for zb0004 := range z {
		o = msgp.AppendUint8(o, uint8(z[zb0004]))
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MethodPath) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(MethodPath, zb0002)
	}
	for zb0001 := range *z {
		{
			var zb0003 uint8
			zb0003, bts, err = msgp.ReadUint8Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			(*z)[zb0001] = MethodID(zb0003)
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MethodPath) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (len(z) * (msgp.Uint8Size))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Reader) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "stream":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Stream")
					return
				}
				z.Stream = nil
			} else {
				if z.Stream == nil {
					z.Stream = new(Stream)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Stream")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Stream")
						return
					}
					switch msgp.UnsafeString(field) {
					case "t":
						{
							var zb0003 uint64
							zb0003, err = dc.ReadUint64()
							if err != nil {
								err = msgp.WrapError(err, "Stream", "Ticket")
								return
							}
							z.Stream.Ticket = StreamTicket(zb0003)
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Stream")
							return
						}
					}
				}
			}
		case "file":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "File")
					return
				}
				z.File = nil
			} else {
				if z.File == nil {
					z.File = new(File)
				}
				var zb0004 uint32
				zb0004, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "File")
					return
				}
				for zb0004 > 0 {
					zb0004--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "File")
						return
					}
					switch msgp.UnsafeString(field) {
					case "filename":
						z.File.Filename, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "File", "Filename")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "File")
							return
						}
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Reader) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Stream == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.File == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "stream"
		err = en.Append(0xa6, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d)
		if err != nil {
			return
		}
		if z.Stream == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 1
			// write "t"
			err = en.Append(0x81, 0xa1, 0x74)
			if err != nil {
				return
			}
			err = en.WriteUint64(uint64(z.Stream.Ticket))
			if err != nil {
				err = msgp.WrapError(err, "Stream", "Ticket")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "file"
		err = en.Append(0xa4, 0x66, 0x69, 0x6c, 0x65)
		if err != nil {
			return
		}
		if z.File == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 1
			// write "filename"
			err = en.Append(0x81, 0xa8, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65)
			if err != nil {
				return
			}
			err = en.WriteString(z.File.Filename)
			if err != nil {
				err = msgp.WrapError(err, "File", "Filename")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Reader) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Stream == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.File == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "stream"
		o = append(o, 0xa6, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d)
		if z.Stream == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 1
			// string "t"
			o = append(o, 0x81, 0xa1, 0x74)
			o = msgp.AppendUint64(o, uint64(z.Stream.Ticket))
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "file"
		o = append(o, 0xa4, 0x66, 0x69, 0x6c, 0x65)
		if z.File == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 1
			// string "filename"
			o = append(o, 0x81, 0xa8, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65)
			o = msgp.AppendString(o, z.File.Filename)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Reader) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "stream":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Stream = nil
			} else {
				if z.Stream == nil {
					z.Stream = new(Stream)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Stream")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Stream")
						return
					}
					switch msgp.UnsafeString(field) {
					case "t":
						{
							var zb0003 uint64
							zb0003, bts, err = msgp.ReadUint64Bytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Stream", "Ticket")
								return
							}
							z.Stream.Ticket = StreamTicket(zb0003)
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Stream")
							return
						}
					}
				}
			}
		case "file":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.File = nil
			} else {
				if z.File == nil {
					z.File = new(File)
				}
				var zb0004 uint32
				zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "File")
					return
				}
				for zb0004 > 0 {
					zb0004--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "File")
						return
					}
					switch msgp.UnsafeString(field) {
					case "filename":
						z.File.Filename, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "File", "Filename")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "File")
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Reader) Msgsize() (s int) {
	s = 1 + 7
	if z.Stream == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.Uint64Size
	}
	s += 5
	if z.File == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 9 + msgp.StringPrefixSize + len(z.File.Filename)
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RegularError) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = RegularError(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z RegularError) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z RegularError) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RegularError) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = RegularError(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z RegularError) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Reply) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "cid":
			{
				var zb0002 uint64
				zb0002, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "CallID")
					return
				}
				z.CallID = CallID(zb0002)
			}
		case "e":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Error")
					return
				}
				z.Error = nil
			} else {
				if z.Error == nil {
					z.Error = new(Error)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Error")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Error")
						return
					}
					switch msgp.UnsafeString(field) {
					case "t":
						{
							var zb0004 uint8
							zb0004, err = dc.ReadUint8()
							if err != nil {
								err = msgp.WrapError(err, "Error", "Type")
								return
							}
							z.Error.Type = ErrorType(zb0004)
						}
					case "d":
						err = z.Error.Data.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "Error", "Data")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Error")
							return
						}
					}
				}
			}
		case "sh":
			{
				var zb0005 uint64
				zb0005, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "StopHandle")
					return
				}
				z.StopHandle = StopHandle(zb0005)
			}
		case "ret":
			err = z.Return.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Return")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Reply) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 4 bits */
	if z.Error == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.StopHandle == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	// write "cid"
	err = en.Append(0xa3, 0x63, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(uint64(z.CallID))
	if err != nil {
		err = msgp.WrapError(err, "CallID")
		return
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "e"
		err = en.Append(0xa1, 0x65)
		if err != nil {
			return
		}
		if z.Error == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 2
			// write "t"
			err = en.Append(0x82, 0xa1, 0x74)
			if err != nil {
				return
			}
			err = en.WriteUint8(uint8(z.Error.Type))
			if err != nil {
				err = msgp.WrapError(err, "Error", "Type")
				return
			}
			// write "d"
			err = en.Append(0xa1, 0x64)
			if err != nil {
				return
			}
			err = z.Error.Data.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Error", "Data")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "sh"
		err = en.Append(0xa2, 0x73, 0x68)
		if err != nil {
			return
		}
		err = en.WriteUint64(uint64(z.StopHandle))
		if err != nil {
			err = msgp.WrapError(err, "StopHandle")
			return
		}
	}
	// write "ret"
	err = en.Append(0xa3, 0x72, 0x65, 0x74)
	if err != nil {
		return
	}
	err = z.Return.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Return")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Reply) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 4 bits */
	if z.Error == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.StopHandle == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	// string "cid"
	o = append(o, 0xa3, 0x63, 0x69, 0x64)
	o = msgp.AppendUint64(o, uint64(z.CallID))
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "e"
		o = append(o, 0xa1, 0x65)
		if z.Error == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "t"
			o = append(o, 0x82, 0xa1, 0x74)
			o = msgp.AppendUint8(o, uint8(z.Error.Type))
			// string "d"
			o = append(o, 0xa1, 0x64)
			o, err = z.Error.Data.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Error", "Data")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "sh"
		o = append(o, 0xa2, 0x73, 0x68)
		o = msgp.AppendUint64(o, uint64(z.StopHandle))
	}
	// string "ret"
	o = append(o, 0xa3, 0x72, 0x65, 0x74)
	o, err = z.Return.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Return")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Reply) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "cid":
			{
				var zb0002 uint64
				zb0002, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CallID")
					return
				}
				z.CallID = CallID(zb0002)
			}
		case "e":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Error = nil
			} else {
				if z.Error == nil {
					z.Error = new(Error)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Error")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Error")
						return
					}
					switch msgp.UnsafeString(field) {
					case "t":
						{
							var zb0004 uint8
							zb0004, bts, err = msgp.ReadUint8Bytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Error", "Type")
								return
							}
							z.Error.Type = ErrorType(zb0004)
						}
					case "d":
						bts, err = z.Error.Data.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Error", "Data")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Error")
							return
						}
					}
				}
			}
		case "sh":
			{
				var zb0005 uint64
				zb0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StopHandle")
					return
				}
				z.StopHandle = StopHandle(zb0005)
			}
		case "ret":
			bts, err = z.Return.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Return")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Reply) Msgsize() (s int) {
	s = 1 + 4 + msgp.Uint64Size + 2
	if z.Error == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.Uint8Size + 2 + z.Error.Data.Msgsize()
	}
	s += 3 + msgp.Uint64Size + 4 + z.Return.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *StopHandle) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 uint64
		zb0001, err = dc.ReadUint64()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = StopHandle(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z StopHandle) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteUint64(uint64(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z StopHandle) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint64(o, uint64(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StopHandle) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint64
		zb0001, bts, err = msgp.ReadUint64Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = StopHandle(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z StopHandle) Msgsize() (s int) {
	s = msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Stream) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "t":
			{
				var zb0002 uint64
				zb0002, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "Ticket")
					return
				}
				z.Ticket = StreamTicket(zb0002)
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Stream) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "t"
	err = en.Append(0x81, 0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(uint64(z.Ticket))
	if err != nil {
		err = msgp.WrapError(err, "Ticket")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Stream) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "t"
	o = append(o, 0x81, 0xa1, 0x74)
	o = msgp.AppendUint64(o, uint64(z.Ticket))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Stream) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "t":
			{
				var zb0002 uint64
				zb0002, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Ticket")
					return
				}
				z.Ticket = StreamTicket(zb0002)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Stream) Msgsize() (s int) {
	s = 1 + 2 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *StreamPacket) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "t":
			{
				var zb0002 uint64
				zb0002, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "Ticket")
					return
				}
				z.Ticket = StreamTicket(zb0002)
			}
		case "b":
			z.Bytes, err = dc.ReadBytes(z.Bytes)
			if err != nil {
				err = msgp.WrapError(err, "Bytes")
				return
			}
		case "e":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Error")
					return
				}
				z.Error = nil
			} else {
				if z.Error == nil {
					z.Error = new(Error)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Error")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Error")
						return
					}
					switch msgp.UnsafeString(field) {
					case "t":
						{
							var zb0004 uint8
							zb0004, err = dc.ReadUint8()
							if err != nil {
								err = msgp.WrapError(err, "Error", "Type")
								return
							}
							z.Error.Type = ErrorType(zb0004)
						}
					case "d":
						err = z.Error.Data.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "Error", "Data")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Error")
							return
						}
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *StreamPacket) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	if z.Bytes == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Error == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(uint64(z.Ticket))
	if err != nil {
		err = msgp.WrapError(err, "Ticket")
		return
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "b"
		err = en.Append(0xa1, 0x62)
		if err != nil {
			return
		}
		err = en.WriteBytes(z.Bytes)
		if err != nil {
			err = msgp.WrapError(err, "Bytes")
			return
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "e"
		err = en.Append(0xa1, 0x65)
		if err != nil {
			return
		}
		if z.Error == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 2
			// write "t"
			err = en.Append(0x82, 0xa1, 0x74)
			if err != nil {
				return
			}
			err = en.WriteUint8(uint8(z.Error.Type))
			if err != nil {
				err = msgp.WrapError(err, "Error", "Type")
				return
			}
			// write "d"
			err = en.Append(0xa1, 0x64)
			if err != nil {
				return
			}
			err = z.Error.Data.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Error", "Data")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StreamPacket) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	if z.Bytes == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Error == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendUint64(o, uint64(z.Ticket))
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "b"
		o = append(o, 0xa1, 0x62)
		o = msgp.AppendBytes(o, z.Bytes)
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "e"
		o = append(o, 0xa1, 0x65)
		if z.Error == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "t"
			o = append(o, 0x82, 0xa1, 0x74)
			o = msgp.AppendUint8(o, uint8(z.Error.Type))
			// string "d"
			o = append(o, 0xa1, 0x64)
			o, err = z.Error.Data.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Error", "Data")
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StreamPacket) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "t":
			{
				var zb0002 uint64
				zb0002, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Ticket")
					return
				}
				z.Ticket = StreamTicket(zb0002)
			}
		case "b":
			z.Bytes, bts, err = msgp.ReadBytesBytes(bts, z.Bytes)
			if err != nil {
				err = msgp.WrapError(err, "Bytes")
				return
			}
		case "e":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Error = nil
			} else {
				if z.Error == nil {
					z.Error = new(Error)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Error")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Error")
						return
					}
					switch msgp.UnsafeString(field) {
					case "t":
						{
							var zb0004 uint8
							zb0004, bts, err = msgp.ReadUint8Bytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Error", "Type")
								return
							}
							z.Error.Type = ErrorType(zb0004)
						}
					case "d":
						bts, err = z.Error.Data.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Error", "Data")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Error")
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StreamPacket) Msgsize() (s int) {
	s = 1 + 2 + msgp.Uint64Size + 2 + msgp.BytesPrefixSize + len(z.Bytes) + 2
	if z.Error == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.Uint8Size + 2 + z.Error.Data.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *StreamRequest) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "t":
			{
				var zb0002 uint64
				zb0002, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "Ticket")
					return
				}
				z.Ticket = StreamTicket(zb0002)
			}
		case "amount":
			z.Amount, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Amount")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z StreamRequest) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "t"
	err = en.Append(0x82, 0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(uint64(z.Ticket))
	if err != nil {
		err = msgp.WrapError(err, "Ticket")
		return
	}
	// write "amount"
	err = en.Append(0xa6, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.Amount)
	if err != nil {
		err = msgp.WrapError(err, "Amount")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z StreamRequest) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "t"
	o = append(o, 0x82, 0xa1, 0x74)
	o = msgp.AppendUint64(o, uint64(z.Ticket))
	// string "amount"
	o = append(o, 0xa6, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint32(o, z.Amount)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StreamRequest) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "t":
			{
				var zb0002 uint64
				zb0002, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Ticket")
					return
				}
				z.Ticket = StreamTicket(zb0002)
			}
		case "amount":
			z.Amount, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Amount")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z StreamRequest) Msgsize() (s int) {
	s = 1 + 2 + msgp.Uint64Size + 7 + msgp.Uint32Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *StreamTicket) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 uint64
		zb0001, err = dc.ReadUint64()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = StreamTicket(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z StreamTicket) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteUint64(uint64(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z StreamTicket) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint64(o, uint64(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StreamTicket) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint64
		zb0001, bts, err = msgp.ReadUint64Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = StreamTicket(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z StreamTicket) Msgsize() (s int) {
	s = msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Time) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int64
		zb0001, err = dc.ReadInt64()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = Time(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Time) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt64(int64(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Time) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt64(o, int64(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Time) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int64
		zb0001, bts, err = msgp.ReadInt64Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = Time(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Time) Msgsize() (s int) {
	s = msgp.Int64Size
	return
}
