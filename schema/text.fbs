// Code generated by ./cmd/internal. DO NOT EDIT.

include "text.fbs";

// Package text provides a rich text API for cchat interfaces to use.
//
//
// Asserting
//
// Although interfaces here contain asserter methods similarly to cchat, the
// backend should take care to not implement multiple interfaces that may seem
// conflicting. For example, if Avatarer is already implemented, then Imager
// shouldn't be.
namespace cchat.text;

file_identifier "TEXT";

// services are names of RPC services that the table implements, if any.
attribute "services";

// Attribute is the type for basic rich text markup attributes.
enum Attribute: uint32 (bit_flags) {
  // Normal is a zero-value attribute.
  Normal,
  // Bold represents bold text.
  Bold,
  // Italics represents italicized text.
  Italics,
  // Underline represents underlined text.
  Underline,
  // Strikethrough represents struckthrough text.
  Strikethrough,
  // Spoiler represents spoiler text, which usually looks blacked out until
  // hovered or clicked on.
  Spoiler,
  // Monospace represents monospaced text, typically for inline code.
  Monospace,
  // Dimmed represents dimmed text, typically slightly less visible than other
  // text.
  Dimmed,
}

// Rich is a normal text wrapped with optional format segments.
table Rich {
  content:string;
  // Segments are optional rich-text segment markers.
  segments:[Segment];
}

// Segment is the minimum requirement for a format segment. Frontends will use
// this to determine when the format starts and ends. They will also assert this
// interface to any other formatting interface, including Linker, Colorer and
// Attributor.
//
// Note that a segment may implement multiple interfaces. For example, a
// Mentioner may also implement Colorer.
table Segment {
  bounds:SegmentBounds;

  // Asserters
  colorer:Colorer;
  linker:Linker;
  imager:Imager;
  avatarer:Avatarer;
  mentioner:Mentioner;
  attributor:Attributor;
  codeblocker:Codeblocker;
  quoteblocker:Quoteblocker;
  message_referencer:MessageReferencer;
}

// SegmentBounds is the return of method Bounds for interface Segment.
table SegmentBounds {
  start:int;
  end:int;
}

// MessageReferencer is similar to Linker, except it references a message
// instead of an arbitrary URL. As such, its appearance may be formatted
// similarly to a link, but this is up to the frontend to decide. When clicked,
// the frontend should scroll to the message with the ID returned by MessageID()
// and highlight it, though this is also for appearance, so the frontend may
// decide in detail how to display it.
table MessageReferencer {
  message_id:string;
}

// Linker is a hyperlink format that a segment could implement. This implies
// that the segment should be replaced with a hyperlink, similarly to the anchor
// tag with href being the URL and the inner text being the text string.
table Linker {
  link:string;
}

// Imager implies the segment should be replaced with a (possibly inlined)
// image.
//
// The Imager segment must return a bound of length zero, that is, the start and
// end bounds must be the same, unless the Imager segment covers something
// meaningful, as images must not substitute texts and only complement them.
//
// An example of the start and end bounds being the same would be any inline
// image, and an Imager that belongs to a Mentioner segment should have its
// bounds overlap. Normally, implementations with separated Mentioner and Imager
// implementations don't have to bother about this, since with Mentioner, the
// same Bounds will be shared, and with Imager, the Bounds method can easily
// return the same variable for start and end.
//
// For segments that also implement mentioner, the image should be treated as a
// square avatar.
table Imager {
  // Image returns the URL for the image.
  image:string;
  // ImageSize returns the requested dimension for the image. This function
  // could return (0, 0), which the frontend should use the image's dimensions.
  image_size:ImagerImageSize;
  // ImageText returns the underlying text of the image. Frontends could use
  // this for hovering or displaying the text instead of the image.
  image_text:string;
}

// ImagerImageSize is the return of method ImageSize for interface Imager.
table ImagerImageSize {
  w:int;
  h:int;
}

// Avatarer implies the segment should be replaced with a rounded-corners image.
// This works similarly to Imager.
//
// For segments that also implement mentioner, the image should be treated as a
// round avatar.
table Avatarer {
  // Avatar returns the URL for the image.
  avatar:string;
  // AvatarSize returns the requested dimension for the image. This function
  // could return (0, 0), which the frontend should use the avatar's dimensions.
  avatar_size:int;
  // AvatarText returns the underlying text of the image. Frontends could use
  // this for hovering or displaying the text instead of the image.
  avatar_text:string;
}

// Colorer is a text color format that a segment could implement. This is to be
// applied directly onto the text.
//
// The Color method must return a valid 32-bit RGBA color. That is, if the text
// color is solid, then the alpha value must be 0xFF. Frontends that support
// 32-bit colors must render alpha accordingly without any edge cases.
table Colorer {
  // Color returns a 32-bit RGBA color.
  color:uint32;
}

// Mentioner implies that the segment can be clickable, and when clicked it
// should open up a dialog containing information from MentionInfo().
//
// It is worth mentioning that frontends should assume whatever segment that
// Mentioner highlighted to be the display name of that user. This would allow
// frontends to flexibly layout the labels.
table Mentioner {
  // MentionInfo returns the popup information of the mentioned segment. This is
  // typically user information or something similar to that context.
  mention_info:cchat.text.Rich;
}

// Attributor is a rich text markup format that a segment could implement. This
// is to be applied directly onto the text.
table Attributor {
  attribute:Attribute;
}

// Codeblocker is a codeblock that supports optional syntax highlighting using
// the language given. Note that as this is a block, it will appear separately
// from the rest of the paragraph.
//
// This interface is equivalent to Markdown's codeblock syntax.
table Codeblocker {
  codeblock_language:string;
}

// Quoteblocker represents a quoteblock that behaves similarly to the blockquote
// HTML tag. The quoteblock may be represented typically by an actaul quoteblock
// or with green arrows prepended to each line.
table Quoteblocker {
  // QuotePrefix returns the prefix that every line the segment covers have.
  // This is typically the greater-than sign ">" in Markdown. Frontends could
  // use this information to format the quote properly.
  quote_prefix:string;
}
