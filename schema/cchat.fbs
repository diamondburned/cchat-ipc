// Code generated by ./cmd/internal. DO NOT EDIT.

include "call.fbs";
include "core.fbs";
include "text.fbs";

// Package cchat is a set of stabilized interfaces for cchat implementations,
// joining the backend and frontend together.
//
//
// Backend
//
// Almost anything in the backend comes with an ID. For example, a Server must
// have an ID, or a Session must have a user ID. The backend is required to
// guarantee that IDs are somehow unique. This should already be the case for
// most chat services; for example, Discord provides IDs for guilds, channels,
// members, and more. The only time that the backend should not guarantee ID
// uniqueness is across Sessions, because it doesn't make sense to do so. In
// this case, the frontend should guarantee uniqueness instead, either by
// discarding duplicated items, overriding them, or anything reasonable and
// explicit.
//
// Methods implemented by the backend that have frontend containers as arguments
// can do IO. Frontends must NOT rely on individual backend states and should
// always assume that they will block.
//
// Methods that do not return an error must NOT do any IO to prevent blocking
// the main thread. As such, ID() and Name() must never do any IO. Methods that
// do return an error may do IO, but they should be documented per method.
//
// Backend implementations have certain conditions that should be adhered to:
//
//  - Storing MessagesContainer and ServersContainer are advised
//  against; however, they should be done if need be.
//  - Other containers such as LabelContainer and IconContainer
//  should also not be stored; however, the same rule as above
//  applies.
//  - For the server list, icon updates and such that happen after
//  their calls should use SetServers().
//  - For the nickname of the current server, the backend can store
//  the state of the label container. It must, however, remove the
//  container when the stop callback from JoinServer() is called.
//  - Some methods that take in a container may take in a context as
//  well.  Although implementations don't have to use this context,
//  it should try to.
//
// Note: IO in most cases usually refer to networking, but they should files and
// anything that is blocking, such as mutexes or semaphores.
//
// Note: As mentioned above, contexts are optional for both the frontend and
// backend. The frontend may use it for cancellation, and the backend may ignore
// it.
//
// Some interfaces can be extended. Interfaces that are extendable will have
// methods starting with "As" and returns another interface type. The
// implementation may or may not return the same struct as the interface, but
// the caller should not have to type assert it to a struct. They can also
// return nil, which should indicate the backend that the feature is not
// implemented.
//
// To avoid confusing, when said "A implements B," it is mostly assumed that A
// has a method named "AsB." It does not mean that A can be type-asserted to B.
//
// For future references, these "As" methods will be called asserter methods.
//
// Note: Backends must not do IO in the "As" methods. Most of the time, it
// should only conditionally check the local state and return value or nil.
//
// Below is an example of checking for an extended interface.
//
//  if iconer := server.AsIconer(); iconer != nil {
//      println("Server implements Iconer.")
//  }
//
//
// Frontend
//
// Frontend contains all interfaces that a frontend can or must implement. The
// backend may call these methods any time from any goroutine. Thus, they should
// be thread-safe. They should also not block the call by doing so, as backends
// may call these methods in its own main thread.
//
// It is worth pointing out that frontend container interfaces will not have an
// error handling API, as frontends can do that themselves. Errors returned by
// backend methods will be errors from the backend itself and never the frontend
// errors.
namespace cchat;

file_identifier "CCHA";

// services are names of RPC services that the table implements, if any.
attribute "services";

// Status represents a user's status. This might be used by the frontend to
// visually display the status.
enum Status: uint8 {
  Unknown,
  Online,
  Idle,
  Busy,
  Away,
  Offline,
  // Invisible is reserved.
  Invisible,
}

// AuthenticateEntry represents a single authentication entry, usually an email
// or password prompt. Passwords or similar entries should have Secrets set to
// true, which should imply to frontends that the fields be masked.
table AuthenticateEntry {
  name:string;
  placeholder:string;
  description:string;
  secret:bool;
  multiline:bool;
}

// CompletionEntry is a single completion entry returned by CompleteMessage. The
// icon URL field is optional.
table CompletionEntry {
  // Raw is the text to be replaced in the input box.
  raw:string;
  // Text is the label to be displayed.
  text:cchat.text.Rich;
  // Secondary is the label to be displayed on the second line, on the right of
  // Text, or not displayed at all. This should be optional. This text may be
  // dimmed out as styling.
  secondary:cchat.text.Rich;
  // IconURL is the URL to the icon that will be displayed on the left of the
  // text. This field is optional.
  icon_url:string;
  // Image returns whether or not the icon URL is actually an image, which
  // indicates that the frontend should not do rounded corners.
  image:bool;
}

// MessageAttachment represents a single file attachment. If needed, the
// frontend will close the reader after the message is sent, that is when the
// SendMessage function returns. The backend must not use the reader after that.
table MessageAttachment {
  reader:cchat.core.Reader;
  name:string;
}

// ErrInvalidConfigAtField is the structure for an error at a specific
// configuration field. Frontends can use this and highlight fields if the
// backends support it.
table ErrInvalidConfigAtField {
  key:string;
  err:cchat.core.Error;
}

// Identifier requires ID() to return a uniquely identifiable string for
// whatever this is embedded into. Typically, servers and messages have IDs. It
// is worth mentioning that IDs should be consistent throughout the lifespan of
// the program or maybe even forever.
table Identifier {
  id:string;
}

// Namer requires Name() to return the name of the object. Typically, this
// implies usernames for sessions or service names for services.
table Namer {
  name:cchat.text.Rich;

  // Asserters
  iconer:Iconer;
}

// Iconer adds icon support into Namer, which in turn is returned by other
// interfaces. Typically, Service would return the service logo, Session would
// return the user's avatar, and Server would return the server icon.
//
// For session, the avatar should be the same as the one returned by messages
// sent by the current user.
table Iconer (services: "IconerService") {}

// IconerService is the service containing call methods for implementations of
// interface Iconer.
rpc_service IconerService {
  Icon(IconParameters):IconReturns;
}

// IconParameters is the parameter table for method Icon of interface Iconer.
table IconParameters {
  call:cchat.call.ID (required);
  ctx:cchat.call.Context;

  icon_container:IconContainer;
}

// IconReturns is the return table for method Icon of interface Iconer.
table IconReturns {
  call:cchat.call.ID (required);
  err:cchat.core.Error;
  stop_handle:cchat.call.StopHandle (required);
}

// Noncer adds nonce support. A nonce is defined in this context as a unique
// identifier from the frontend. This interface defines the common nonce getter.
//
// Nonces are useful for frontends to know if an incoming event is a reply from
// the server backend. As such, nonces should be roundtripped through the
// server. For example, IRC would use labeled responses.
//
// The Nonce method can return an empty string. This indicates that either the
// frontend or backend (or neither) supports nonces.
//
// Contrary to other interfaces that extend with an "Is" method, the Nonce
// method could return an empty string here.
table Noncer {
  nonce:string;
}

// Author is the interface for an identifiable author. The interface defines
// that an author always have an ID and a name.
//
// An example of where this interface is used would be in MessageCreate's Author
// method or embedded in Typer. The returned ID may or may not be used by the
// frontend, but backends must guarantee that the Author's ID is in fact a user
// ID.
//
// The frontend may use the ID to squash messages with the same author together.
table Author {
  id:string;
  name:cchat.text.Rich;
  // Avatar returns the URL to the user's avatar or an empty string if they have
  // no avatar or the service does not have any avatars.
  avatar:string;
}

// A service is a complete service that's capable of multiple sessions. It has
// to implement the Authenticate() method, which returns multiple
// implementations of Authenticator.
//
// A service can implement SessionRestorer, which would indicate the frontend
// that it can restore past sessions. Sessions are saved using the SessionSaver
// interface that Session can implement.
//
// A service can also implement Configurator if it has additional
// configurations. The current API is a flat key-value map, which can be parsed
// by the backend itself into more meaningful data structures. All
// configurations must be optional, as frontends may not implement a
// configurator UI.
table Service {
  name:cchat.text.Rich;
  authenticate:[Authenticator];

  // Asserters
  iconer:Iconer;
  configurator:Configurator;
  session_restorer:SessionRestorer;
}

// AuthenticateError is the error returned when authenticating. This error
// interface extends the normal error to allow backends to implement multi-stage
// authentication if needed in a clean way without needing any loops.
//
// This interface satisfies the error interface.
table AuthenticateError {
  // Error returns the error as a string. This method makes AuthenticateError
  // satisfy the built-in error interface.
  err:string;
  // NextStage optionally returns a slice of Authenticator interfaces if the
  // authentication process requires another stage. It works similarly to
  // Service's Authenticate method, both of which returns a slice of
  // Authenticators.
  //
  // If the error returned is an actual error, and that the user should retry
  // any of the authentication fields, then NextStage could return nil to
  // signify the error. The frontend could reliably check nil on this field to
  // determine whether or not it should recreate the authentication fields.
  next_stage:[Authenticator];
}

// The authenticator interface allows for a multistage initial authentication
// API that the backend could use. Multistage is done by calling Authenticate
// and check for AuthenticateError's NextStage method.
table Authenticator (services: "AuthenticatorService") {
  // Name returns a short and concise name of this Authenticator method. The
  // name should not include the name of the Service.
  name:cchat.text.Rich;
  // Description returns the description of this authenticator method.
  description:cchat.text.Rich;
  // AuthenticateForm should return a list of authentication entries for the
  // frontend to render.
  authenticate_form:[AuthenticateEntry];
}

// AuthenticatorService is the service containing call methods for
// implementations of interface Authenticator.
rpc_service AuthenticatorService {
  // Authenticate will be called with a list of values with indices correspond
  // to the returned slice of AuthenticateEntry.
  Authenticate(AuthenticateParameters):AuthenticateReturns;
}

// AuthenticateParameters is the parameter table for method Authenticate of
// interface Authenticator.
table AuthenticateParameters {
  call:cchat.call.ID (required);

  string_array:[string];
}

// AuthenticateReturns is the return table for method Authenticate of interface
// Authenticator.
table AuthenticateReturns {
  call:cchat.call.ID (required);

  session:Session;
  err:cchat.core.Error;
}

// SessionRestorer extends Service and is called by the frontend to restore a
// saved session. The frontend may call this at any time, but it's usually on
// startup.
//
// To save a session, refer to SessionSaver.
table SessionRestorer (services: "SessionRestorerService") {}

// SessionRestorerService is the service containing call methods for
// implementations of interface SessionRestorer.
rpc_service SessionRestorerService {
  RestoreSession(RestoreSessionParameters):RestoreSessionReturns;
}

// RestoreSessionParameters is the parameter table for method RestoreSession of
// interface SessionRestorer.
table RestoreSessionParameters {
  call:cchat.call.ID (required);

  map_string_string:cchat.core.StringPair;
}

// RestoreSessionReturns is the return table for method RestoreSession of
// interface SessionRestorer.
table RestoreSessionReturns {
  call:cchat.call.ID (required);

  session:Session;
  err:cchat.core.Error;
}

// Configurator is an interface which the backend can implement for a primitive
// configuration API. Since these methods do return an error, they are allowed
// to do IO. The frontend should handle this appropriately, including running
// them asynchronously.
table Configurator (services: "ConfiguratorService") {}

// ConfiguratorService is the service containing call methods for
// implementations of interface Configurator.
rpc_service ConfiguratorService {
  Configuration(ConfigurationParameters):ConfigurationReturns;
  SetConfiguration(SetConfigurationParameters):SetConfigurationReturns;
}

// ConfigurationParameters is the parameter table for method Configuration of
// interface Configurator.
table ConfigurationParameters {
  call:cchat.call.ID (required);
}

// ConfigurationReturns is the return table for method Configuration of
// interface Configurator.
table ConfigurationReturns {
  call:cchat.call.ID (required);

  map_string_string:cchat.core.StringPair;
  err:cchat.core.Error;
}

// SetConfigurationParameters is the parameter table for method SetConfiguration
// of interface Configurator.
table SetConfigurationParameters {
  call:cchat.call.ID (required);

  map_string_string:cchat.core.StringPair;
}

// SetConfigurationReturns is the return table for method SetConfiguration of
// interface Configurator.
table SetConfigurationReturns {
  call:cchat.call.ID (required);

  err:cchat.core.Error;
}

// A session is returned after authentication on the service. Session implements
// Name(), which should return the username most of the time. It also implements
// ID(), which might be used by frontends to check against MessageAuthor.ID()
// and other things.
//
// A session can implement SessionSaver, which would allow the frontend to save
// the session into its keyring at any time. Whether the keyring is completely
// secure or not is up to the frontend. For a Gtk client, that would be using
// the GNOME Keyring daemon.
table Session (services: "SessionService, ListerService") {
  id:string;
  name:cchat.text.Rich;

  // Asserters
  iconer:Iconer;
  commander:Commander;
  session_saver:SessionSaver;
}

// SessionService is the service containing call methods for implementations of
// interface Session.
rpc_service SessionService {
  // Disconnect asks the service to disconnect. It does not necessarily mean
  // removing the service.
  //
  // The frontend must cancel the active ServerMessage before disconnecting. The
  // backend can rely on this behavior.
  //
  // The frontend will reuse the stored session data from SessionSaver to
  // reconnect.
  //
  // When this function fails, the frontend may display the error upfront.
  // However, it will treat the session as actually disconnected. If needed, the
  // backend must implement reconnection by itself.
  Disconnect(DisconnectParameters):DisconnectReturns;
}

// DisconnectParameters is the parameter table for method Disconnect of
// interface Session.
table DisconnectParameters {
  call:cchat.call.ID (required);
}

// DisconnectReturns is the return table for method Disconnect of interface
// Session.
table DisconnectReturns {
  call:cchat.call.ID (required);

  err:cchat.core.Error;
}

// SessionSaver extends Session and is called by the frontend to save the
// current session. This is typically called right after authentication, but a
// frontend may call this any time, including when it's closing.
//
// The frontend can ask to restore a session using SessionRestorer, which
// extends Service.
//
// The SaveSession method must not do IO; if there are any reasons that cause
// SaveSession to fail, then a nil map should be returned.
table SessionSaver {
  save_session:cchat.core.StringPair;
}

// Commander is an optional interface that a session could implement for command
// support. This is different from just intercepting the SendMessage() API, as
// this extends globally to the entire session.
//
// A very primitive use of this API would be to provide additional features that
// are not in cchat through a very basic terminal interface.
table Commander (services: "CommanderService") {

  // Asserters
  completer:Completer;
}

// CommanderService is the service containing call methods for implementations
// of interface Commander.
rpc_service CommanderService {
  // Run executes the given command, with the slice being already split
  // arguments, similar to os.Args. The function can return both a []byte and an
  // error value. The frontend should render the byte slice's value first, then
  // display the error.
  //
  // This function can do IO.
  //
  // The client should make guarantees that an empty string (and thus a
  // zero-length string slice) should be ignored. The backend should be able to
  // assume that the argument slice is always length 1 or more.
  //
  //
  // Words
  //
  // This interface and everything else inside this interface must abide by
  // shell rules when splitting words. This is in contrary to the default
  // behavior elsewhere, such as in Sender's Completer, where words are split by
  // whitespace without care for quotes.
  //
  // For example, provided this string:
  //
  //  echo "This is a string"
  //
  // This is the correct output:
  //
  //  []string{"echo", "This is a string"}
  //
  // This is the incorrect output:
  //
  //  []string{"echo", "\"This", "is", "a", "string\""}
  //
  // A helper function for this kind of behavior is available in package split,
  // under the ArgsIndexed function. This implementation also provides the rough
  // specifications.
  Run(RunParameters):RunReturns;
}

// RunParameters is the parameter table for method Run of interface Commander.
table RunParameters {
  call:cchat.call.ID (required);

  words:[string];
}

// RunReturns is the return table for method Run of interface Commander.
table RunReturns {
  call:cchat.call.ID (required);

  byte_array:[byte];
  err:cchat.core.Error;
}

// Server is a single server-like entity that could translate to a guild, a
// channel, a chat-room, and such. A server must implement at least ServerList
// or ServerMessage, else the frontend must treat it as a no-op.
table Server {
  id:string;
  name:cchat.text.Rich;

  // Asserters
  iconer:Iconer;
  lister:Lister;
  messenger:Messenger;
  commander:Commander;
  configurator:Configurator;
}

// Lister is for servers that contain children servers. This is similar to
// guilds containing channels in Discord, or IRC servers containing channels.
//
// There isn't a similar stop callback API unlike other interfaces because all
// servers are expected to be listed. However, they could be hidden, such as
// collapsing a tree.
//
// The backend should call both the container and other icon and label
// containers, if any.
table Lister (services: "ListerService") {}

// ListerService is the service containing call methods for implementations of
// interface Lister.
rpc_service ListerService {
  // Servers should call SetServers() on the given ServersContainer to render
  // all servers. This function can do IO, and the frontend should run this in a
  // goroutine.
  Servers(ServersParameters):ServersReturns;
}

// ServersParameters is the parameter table for method Servers of interface
// Lister.
table ServersParameters {
  call:cchat.call.ID (required);

  servers_container:ServersContainer;
}

// ServersReturns is the return table for method Servers of interface Lister.
table ServersReturns {
  call:cchat.call.ID (required);
  err:cchat.core.Error;
}

// Messenger is for servers that contain messages. This is similar to Discord or
// IRC channels.
table Messenger (services: "MessengerService") {

  // Asserters
  sender:Sender;
  editor:Editor;
  actioner:Actioner;
  nicknamer:Nicknamer;
  backlogger:Backlogger;
  member_lister:MemberLister;
  unread_indicator:UnreadIndicator;
  typing_indicator:TypingIndicator;
}

// MessengerService is the service containing call methods for implementations
// of interface Messenger.
rpc_service MessengerService {
  // JoinServer joins a server that's capable of receiving messages. The server
  // may not necessarily support sending messages.
  //
  // Frontends must never call JoinServer on the same server more than twice
  // without calling the stop function first. This is the best of both worlds,
  // as it greatly reduces complexity on both sides in most cases, therefore the
  // backend can safely assume that there will only ever be one active
  // JoinServer. If the frontend wishes to do this, it must keep its own shared
  // message buffer.
  JoinServer(JoinServerParameters):JoinServerReturns;
}

// JoinServerParameters is the parameter table for method JoinServer of
// interface Messenger.
table JoinServerParameters {
  call:cchat.call.ID (required);
  ctx:cchat.call.Context;

  messages_container:MessagesContainer;
}

// JoinServerReturns is the return table for method JoinServer of interface
// Messenger.
table JoinServerReturns {
  call:cchat.call.ID (required);
  err:cchat.core.Error;
  stop_handle:cchat.call.StopHandle (required);
}

// Sender adds message sending to a messenger. Messengers that don't implement
// MessageSender will be considered read-only.
table Sender (services: "SenderService") {
  // CanAttach returns whether or not the client is allowed to upload files.
  can_attach:bool;

  // Asserters
  completer:Completer;
}

// SenderService is the service containing call methods for implementations of
// interface Sender.
rpc_service SenderService {
  // Send is called by the frontend to send a message to this channel.
  Send(SendParameters):SendReturns;
}

// SendParameters is the parameter table for method Send of interface Sender.
table SendParameters {
  call:cchat.call.ID (required);

  sendable_message:SendableMessage;
}

// SendReturns is the return table for method Send of interface Sender.
table SendReturns {
  call:cchat.call.ID (required);

  err:cchat.core.Error;
}

// Editor adds message editing to the messenger. Only EditMessage can do IO.
table Editor (services: "EditorService") {}

// EditorService is the service containing call methods for implementations of
// interface Editor.
rpc_service EditorService {
  // IsEditable returns whether or not a message can be edited by the client.
  // This method must not do IO.
  IsEditable(IsEditableParameters):IsEditableReturns;
  // RawContent gets the original message text for editing. This method must not
  // do IO.
  RawContent(RawContentParameters):RawContentReturns;
  // Edit edits the message with the given ID to the given content, which is the
  // edited string from RawMessageContent. This method can do IO.
  Edit(EditParameters):EditReturns;
}

// IsEditableParameters is the parameter table for method IsEditable of
// interface Editor.
table IsEditableParameters {
  call:cchat.call.ID (required);

  id:string;
}

// IsEditableReturns is the return table for method IsEditable of interface
// Editor.
table IsEditableReturns {
  call:cchat.call.ID (required);
}

// RawContentParameters is the parameter table for method RawContent of
// interface Editor.
table RawContentParameters {
  call:cchat.call.ID (required);

  id:string;
}

// RawContentReturns is the return table for method RawContent of interface
// Editor.
table RawContentReturns {
  call:cchat.call.ID (required);
  err:cchat.core.Error;
}

// EditParameters is the parameter table for method Edit of interface Editor.
table EditParameters {
  call:cchat.call.ID (required);

  id:string;
  content:string;
}

// EditReturns is the return table for method Edit of interface Editor.
table EditReturns {
  call:cchat.call.ID (required);

  err:cchat.core.Error;
}

// Actioner adds custom message actions into each message. Similarly to
// ServerMessageEditor, some of these methods may do IO.
table Actioner (services: "ActionerService") {}

// ActionerService is the service containing call methods for implementations of
// interface Actioner.
rpc_service ActionerService {
  // MessageActions returns a list of possible actions to a message in pretty
  // strings that the frontend will use to directly display. This method must
  // not do IO.
  //
  // The string slice returned can be nil or empty.
  Actions(ActionsParameters):ActionsReturns;
  // Do executes a message action on the given messageID, which would be taken
  // from MessageHeader.ID(). This method is allowed to do IO; the frontend
  // should take care of running it asynchronously.
  Do(DoParameters):DoReturns;
}

// ActionsParameters is the parameter table for method Actions of interface
// Actioner.
table ActionsParameters {
  call:cchat.call.ID (required);

  id:string;
}

// ActionsReturns is the return table for method Actions of interface Actioner.
table ActionsReturns {
  call:cchat.call.ID (required);
}

// DoParameters is the parameter table for method Do of interface Actioner.
table DoParameters {
  call:cchat.call.ID (required);

  action:string;
  id:string;
}

// DoReturns is the return table for method Do of interface Actioner.
table DoReturns {
  call:cchat.call.ID (required);

  err:cchat.core.Error;
}

// Nicknamer adds the current user's nickname.
//
// The frontend will not traverse up the server tree, meaning the backend must
// handle nickname inheritance. This also means that servers that don't
// implement ServerMessage also don't need to implement ServerNickname. By
// default, the session name should be used.
table Nicknamer (services: "NicknamerService") {}

// NicknamerService is the service containing call methods for implementations
// of interface Nicknamer.
rpc_service NicknamerService {
  Nickname(NicknameParameters):NicknameReturns;
}

// NicknameParameters is the parameter table for method Nickname of interface
// Nicknamer.
table NicknameParameters {
  call:cchat.call.ID (required);
  ctx:cchat.call.Context;

  label_container:LabelContainer;
}

// NicknameReturns is the return table for method Nickname of interface
// Nicknamer.
table NicknameReturns {
  call:cchat.call.ID (required);
  err:cchat.core.Error;
  stop_handle:cchat.call.StopHandle (required);
}

// Backlogger adds message history capabilities into a message container. The
// backend should send old messages using the MessageCreate method of the
// MessageContainer, and the frontend should automatically sort messages based
// on the timestamp.
//
// As there is no stop callback, if the backend needs to fetch messages
// asynchronously, it is expected to use the context to know when to cancel.
//
// The frontend should usually call this method when the user scrolls to the
// top. It is expected to guarantee not to call Backlogger more than once on the
// same ID. This can usually be done by deactivating the UI.
//
// Note that the optional usage of contexts also apply here. The frontend should
// deactivate the UI when the backend is working. However, the frontend can
// accomodate this by not deactivating until another event is triggered, then
// freeze the UI until the method is cancelled. This works even when the backend
// does not use the context.
table Backlogger (services: "BackloggerService") {}

// BackloggerService is the service containing call methods for implementations
// of interface Backlogger.
rpc_service BackloggerService {
  // Backlog fetches messages before the given message ID into the
  // MessagesContainer.
  //
  // This method is technically a ContainerMethod, but is listed as an IOMethod
  // because of the additional message ID parameter.
  Backlog(BacklogParameters):BacklogReturns;
}

// BacklogParameters is the parameter table for method Backlog of interface
// Backlogger.
table BacklogParameters {
  call:cchat.call.ID (required);

  ctx:cchat.call.Context;
  before:string;
  msgc:MessagesContainer;
}

// BacklogReturns is the return table for method Backlog of interface
// Backlogger.
table BacklogReturns {
  call:cchat.call.ID (required);

  err:cchat.core.Error;
}

// MemberLister adds a member list into a message server.
table MemberLister (services: "MemberListerService") {}

// MemberListerService is the service containing call methods for
// implementations of interface MemberLister.
rpc_service MemberListerService {
  // ListMembers assigns the given container to the channel's member list. The
  // given context may be used to provide HTTP request cancellations, but
  // frontends must not rely solely on this, as the general context rules
  // applies.
  //
  // Further behavioral documentations may be in Messenger's JoinServer method.
  ListMembers(ListMembersParameters):ListMembersReturns;
}

// ListMembersParameters is the parameter table for method ListMembers of
// interface MemberLister.
table ListMembersParameters {
  call:cchat.call.ID (required);
  ctx:cchat.call.Context;

  member_list_container:MemberListContainer;
}

// ListMembersReturns is the return table for method ListMembers of interface
// MemberLister.
table ListMembersReturns {
  call:cchat.call.ID (required);
  err:cchat.core.Error;
  stop_handle:cchat.call.StopHandle (required);
}

// UnreadIndicator adds an unread state API for frontends to use.
table UnreadIndicator (services: "UnreadIndicatorService") {}

// UnreadIndicatorService is the service containing call methods for
// implementations of interface UnreadIndicator.
rpc_service UnreadIndicatorService {
  // UnreadIndicate subscribes the given unread indicator for unread and mention
  // events. Examples include when a new message is arrived and the backend
  // needs to indicate that it's unread.
  //
  // This function must provide a way to remove callbacks, as clients must call
  // this when the old server is destroyed, such as when Servers is called.
  UnreadIndicate(UnreadIndicateParameters):UnreadIndicateReturns;
}

// UnreadIndicateParameters is the parameter table for method UnreadIndicate of
// interface UnreadIndicator.
table UnreadIndicateParameters {
  call:cchat.call.ID (required);

  unread_container:UnreadContainer;
}

// UnreadIndicateReturns is the return table for method UnreadIndicate of
// interface UnreadIndicator.
table UnreadIndicateReturns {
  call:cchat.call.ID (required);
  err:cchat.core.Error;
  stop_handle:cchat.call.StopHandle (required);
}

// TypingIndicator optionally extends ServerMessage to provide bidirectional
// typing indicating capabilities. This is similar to typing events on Discord
// and typing client tags on IRCv3.
//
// The client should remove a typer when a message is received with the same
// user ID, when RemoveTyper() is called by the backend or when the timeout
// returned from TypingTimeout() has been reached.
table TypingIndicator (services: "TypingIndicatorService") {
  // TypingTimeout returns the interval between typing events sent by the client
  // as well as the timeout before the client should remove the typer.
  // Typically, a constant should be returned.
  typing_timeout:int64;
}

// TypingIndicatorService is the service containing call methods for
// implementations of interface TypingIndicator.
rpc_service TypingIndicatorService {
  // Typing is called by the client to indicate that the user is typing. This
  // function can do IO calls, and the client must take care of calling it in a
  // goroutine (or an asynchronous queue) as well as throttling it to
  // TypingTimeout.
  Typing(TypingParameters):TypingReturns;
  // TypingSubscribe subscribes the given indicator to typing events sent by the
  // backend. The added event handlers have to be removed by the backend when
  // the stop() callback is called.
  //
  // This method does not take in a context, as it's supposed to only use event
  // handlers and not do any IO calls. Nonetheless, the client must treat it
  // like it does and call it asynchronously.
  TypingSubscribe(TypingSubscribeParameters):TypingSubscribeReturns;
}

// TypingParameters is the parameter table for method Typing of interface
// TypingIndicator.
table TypingParameters {
  call:cchat.call.ID (required);
}

// TypingReturns is the return table for method Typing of interface
// TypingIndicator.
table TypingReturns {
  call:cchat.call.ID (required);

  err:cchat.core.Error;
}

// TypingSubscribeParameters is the parameter table for method TypingSubscribe
// of interface TypingIndicator.
table TypingSubscribeParameters {
  call:cchat.call.ID (required);

  typing_container:TypingContainer;
}

// TypingSubscribeReturns is the return table for method TypingSubscribe of
// interface TypingIndicator.
table TypingSubscribeReturns {
  call:cchat.call.ID (required);
  err:cchat.core.Error;
  stop_handle:cchat.call.StopHandle (required);
}

// Completer adds autocompletion into the message composer. IO is not allowed,
// and the backend should do that only in goroutines and update its state for
// future calls.
//
// Frontends could utilize the split package inside utils for splitting words
// and index. This is the de-facto standard implementation for splitting words,
// thus backends can rely on their behaviors.
table Completer (services: "CompleterService") {}

// CompleterService is the service containing call methods for implementations
// of interface Completer.
rpc_service CompleterService {
  // Complete returns the list of possible completion entries for the given word
  // list and the current word index. It takes in a list of whitespace-split
  // slice of string as well as the position of the cursor relative to the given
  // string slice.
  Complete(CompleteParameters):CompleteReturns;
}

// CompleteParameters is the parameter table for method Complete of interface
// Completer.
table CompleteParameters {
  call:cchat.call.ID (required);

  words:[string];
  current:int64;
}

// CompleteReturns is the return table for method Complete of interface
// Completer.
table CompleteReturns {
  call:cchat.call.ID (required);
}

// ServersContainer is any type of view that displays the list of servers. It
// should implement a SetServers([]Server) that the backend could use to call
// anytime the server list changes (at all).
//
// Typically, most frontends should implement this interface onto a tree node,
// as servers can be infinitely nested. Frontends should also reset the entire
// node and its children when SetServers is called again.
table ServersContainer (services: "ServersContainerService") {}

// ServersContainerService is the service containing call methods for
// implementations of interface ServersContainer.
rpc_service ServersContainerService {
  // SetServer is called by the backend service to request a reset of the server
  // list. The frontend can choose to call Servers() on each of the given
  // servers, or it can call that later. The backend should handle both cases.
  SetServers(SetServersParameters):cchat.call.NoReply;
  UpdateServer(UpdateServerParameters):cchat.call.NoReply;
}

// SetServersParameters is the parameter table for method SetServers of
// interface ServersContainer.
table SetServersParameters {
  call:cchat.call.ID (required);

  server_array:[Server];
}

// UpdateServerParameters is the parameter table for method UpdateServer of
// interface ServersContainer.
table UpdateServerParameters {
  call:cchat.call.ID (required);

  server_update:ServerUpdate;
}

// ServerUpdate represents a server update event.
table ServerUpdate {
  id:string;
  name:cchat.text.Rich;
  // PreviousID returns the ID of the item, either to be replaced or to be
  // inserted in front of.
  //
  // If replace is true, then the returned ID is the ID of the item to be
  // replaced, and the frontend should only try to use the ID as-is to find the
  // old server and replace.
  //
  // If replace is false, then the returned ID will be the ID of the item in
  // front of the embedded server. If the ID is empty or the frontend cannot
  // find the server from this ID, then it should assume and prepend the server
  // to the start.
  previous_id:ServerUpdatePreviousID;

  // Asserters
  iconer:Iconer;
  lister:Lister;
  messenger:Messenger;
  commander:Commander;
  configurator:Configurator;
}

// ServerUpdatePreviousID is the return of method PreviousID for interface
// ServerUpdate.
table ServerUpdatePreviousID {
  server_id:string;
  replace:bool;
}

// MessagesContainer is a view implementation that displays a list of messages
// live. This implements the 3 most common message events: CreateMessage,
// UpdateMessage and DeleteMessage. The frontend must handle all 3.
//
// Since this container interface extends a single Server, the frontend is
// allowed to have multiple views. This is usually done with tabs or splits, but
// the backend should update them all nonetheless.
table MessagesContainer (services: "MessagesContainerService") {}

// MessagesContainerService is the service containing call methods for
// implementations of interface MessagesContainer.
rpc_service MessagesContainerService {
  // CreateMessage inserts a message into the container. The frontend must
  // guarantee that the messages are in order based on what's returned from
  // Time().
  CreateMessage(CreateMessageParameters):cchat.call.NoReply;
  UpdateMessage(UpdateMessageParameters):cchat.call.NoReply;
  DeleteMessage(DeleteMessageParameters):cchat.call.NoReply;
}

// CreateMessageParameters is the parameter table for method CreateMessage of
// interface MessagesContainer.
table CreateMessageParameters {
  call:cchat.call.ID (required);

  message_create:MessageCreate;
}

// UpdateMessageParameters is the parameter table for method UpdateMessage of
// interface MessagesContainer.
table UpdateMessageParameters {
  call:cchat.call.ID (required);

  message_update:MessageUpdate;
}

// DeleteMessageParameters is the parameter table for method DeleteMessage of
// interface MessagesContainer.
table DeleteMessageParameters {
  call:cchat.call.ID (required);

  message_delete:MessageDelete;
}

// MessageHeader implements the minimum interface for any message event.
table MessageHeader {
  id:string;
  time:cchat.core.Time;
}

// MessageCreate is the interface for an incoming message.
table MessageCreate {
  id:string;
  time:cchat.core.Time;
  nonce:string;
  author:Author;
  content:cchat.text.Rich;
  // Mentioned returns whether or not the message mentions the current user. If
  // a backend does not implement mentioning, then false can be returned.
  mentioned:bool;
}

// MessageUpdate is the interface for a message update (or edit) event. If the
// returned text.Rich returns true for Empty(), then the element shouldn't be
// changed.
table MessageUpdate {
  id:string;
  time:cchat.core.Time;
  author:Author;
  content:cchat.text.Rich;
}

// MessageDelete is the interface for a message delete event.
table MessageDelete {
  id:string;
  time:cchat.core.Time;
}

// LabelContainer is a generic interface for any container that can hold texts.
// It's typically used for rich text labelling for usernames and server names.
//
// Methods that takes in a LabelContainer typically holds it in the state and
// may call SetLabel any time it wants. Thus, the frontend should synchronize
// calls with the main thread if needed.
table LabelContainer (services: "LabelContainerService") {}

// LabelContainerService is the service containing call methods for
// implementations of interface LabelContainer.
rpc_service LabelContainerService {
  SetLabel(SetLabelParameters):cchat.call.NoReply;
}

// SetLabelParameters is the parameter table for method SetLabel of interface
// LabelContainer.
table SetLabelParameters {
  call:cchat.call.ID (required);

  rich:cchat.text.Rich;
}

// IconContainer is a generic interface for any container that can hold an
// image. It's typically used for icons that can update itself. Frontends should
// round these icons. For images that shouldn't be rounded, use ImageContainer.
//
// Methods may call SetIcon at any time in its main thread, so the frontend must
// do any I/O (including downloading the image) in another goroutine to avoid
// blocking the backend.
table IconContainer (services: "IconContainerService") {}

// IconContainerService is the service containing call methods for
// implementations of interface IconContainer.
rpc_service IconContainerService {
  SetIcon(SetIconParameters):cchat.call.NoReply;
}

// SetIconParameters is the parameter table for method SetIcon of interface
// IconContainer.
table SetIconParameters {
  call:cchat.call.ID (required);

  url:string;
}

// ImageContainer is a generic interface for any container that can hold an
// image. It's typically used for icons that can update itself. Frontends should
// not round these icons. For images that should be rounded, use IconContainer.
//
// Methods may call SetIcon at any time in its main thread, so the frontend must
// do any I/O (including downloading the image) in another goroutine to avoid
// blocking the backend.
table ImageContainer (services: "ImageContainerService") {}

// ImageContainerService is the service containing call methods for
// implementations of interface ImageContainer.
rpc_service ImageContainerService {
  SetImage(SetImageParameters):cchat.call.NoReply;
}

// SetImageParameters is the parameter table for method SetImage of interface
// ImageContainer.
table SetImageParameters {
  call:cchat.call.ID (required);

  url:string;
}

// UnreadContainer is an interface that a single server container (such as a
// button or a tree node) can implement if it's capable of indicating the read
// and mentioned status for that channel.
//
// Server containers that implement this has to represent unread and mentioned
// differently. For example, a mentioned channel could have a red outline, while
// an unread channel could appear brighter.
//
// Server containers are expected to represent this information in their parent
// nodes as well. For example, if a server is unread, then its parent servers as
// well as the session node should indicate the same status. Highlighting the
// session and service nodes are, however, implementation details, meaning that
// this decision is up to the frontend to decide.
table UnreadContainer (services: "UnreadContainerService") {}

// UnreadContainerService is the service containing call methods for
// implementations of interface UnreadContainer.
rpc_service UnreadContainerService {
  // SetUnread sets the container's unread state to the given boolean. The
  // frontend may choose how to represent this.
  SetUnread(SetUnreadParameters):cchat.call.NoReply;
}

// SetUnreadParameters is the parameter table for method SetUnread of interface
// UnreadContainer.
table SetUnreadParameters {
  call:cchat.call.ID (required);

  unread:bool;
  mentioned:bool;
}

// TypingContainer is a generic interface for any container that can display
// users typing in the current chatbox. The typing indicator must adhere to the
// TypingTimeout returned from ServerMessageTypingIndicator. The backend should
// assume that to be the case and send events appropriately.
//
// For more documentation, refer to TypingIndicator.
table TypingContainer (services: "TypingContainerService") {}

// TypingContainerService is the service containing call methods for
// implementations of interface TypingContainer.
rpc_service TypingContainerService {
  // AddTyper appends the typer into the frontend's list of typers, or it pushes
  // this typer on top of others.
  AddTyper(AddTyperParameters):cchat.call.NoReply;
  // RemoveTyper explicitly removes the typer with the given user ID from the
  // list of typers. This function is usually not needed, as the client will
  // take care of removing them after TypingTimeout has been reached or other
  // conditions listed in ServerMessageTypingIndicator are met.
  RemoveTyper(RemoveTyperParameters):cchat.call.NoReply;
}

// AddTyperParameters is the parameter table for method AddTyper of interface
// TypingContainer.
table AddTyperParameters {
  call:cchat.call.ID (required);

  typer:Typer;
}

// RemoveTyperParameters is the parameter table for method RemoveTyper of
// interface TypingContainer.
table RemoveTyperParameters {
  call:cchat.call.ID (required);

  typer_id:string;
}

// Typer is an individual user that's typing. This interface is used
// interchangably in TypingIndicator and thus ServerMessageTypingIndicator as
// well.
table Typer {
  id:string;
  name:cchat.text.Rich;
  // Avatar returns the URL to the user's avatar or an empty string if they have
  // no avatar or the service does not have any avatars.
  avatar:string;
  time:cchat.core.Time;
}

// MemberListContainer is a generic interface for any container that can display
// a member list. This is similar to Discord's right-side member list or IRC's
// users list. Below is a visual representation of a typical member list
// container:
//
//  +-MemberList-----------\
//  | +-Section------------|
//  | |                    |
//  | | Header - Total     |
//  | |                    |
//  | | +-Member-----------|
//  | | | Name             |
//  | | |   Secondary      |
//  | | \__________________|
//  | |                    |
//  | | +-Member-----------|
//  | | | Name             |
//  | | |   Secondary      |
//  | | \__________________|
//  \_\____________________/
table MemberListContainer (services: "MemberListContainerService") {}

// MemberListContainerService is the service containing call methods for
// implementations of interface MemberListContainer.
rpc_service MemberListContainerService {
  // SetSections (re)sets the list of sections to be the given slice. Members
  // from the old section list should be transferred over to the new section
  // entry if the section name's content is the same. Old sections that don't
  // appear in the new slice should be removed.
  SetSections(SetSectionsParameters):cchat.call.NoReply;
  // SetMember adds or updates (or upsert) a member into a section. This
  // operation must not change the section's member count. As such, changes
  // should be done separately in SetSection. If the section does not exist,
  // then the client should ignore this member. As such, backends must call
  // SetSections first before SetMember on a new section.
  SetMember(SetMemberParameters):cchat.call.NoReply;
  // RemoveMember removes a member from a section. If neither the member nor the
  // section exists, then the client should ignore it.
  RemoveMember(RemoveMemberParameters):cchat.call.NoReply;
}

// SetSectionsParameters is the parameter table for method SetSections of
// interface MemberListContainer.
table SetSectionsParameters {
  call:cchat.call.ID (required);

  sections:[MemberSection];
}

// SetMemberParameters is the parameter table for method SetMember of interface
// MemberListContainer.
table SetMemberParameters {
  call:cchat.call.ID (required);

  section_id:string;
  member:ListMember;
}

// RemoveMemberParameters is the parameter table for method RemoveMember of
// interface MemberListContainer.
table RemoveMemberParameters {
  call:cchat.call.ID (required);

  section_id:string;
  member_id:string;
}

// ListMember represents a single member in the member list. This is a base
// interface that may implement more interfaces, such as Iconer for the user's
// avatar.
//
// Note that the frontend may give everyone an avatar regardless, or it may not
// show any avatars at all.
table ListMember {
  id:string;
  name:cchat.text.Rich;
  // Status returns the status of the member. The backend does not have to show
  // offline members with the offline status if it doesn't want to show offline
  // menbers at all.
  status:Status;
  // Secondary returns the subtext of this member. This could be anything, such
  // as a user's custom status or away reason.
  secondary:cchat.text.Rich;

  // Asserters
  iconer:Iconer;
}

// MemberSection represents a member list section. The section name's content
// must be unique among other sections from the same list regardless of the rich
// segments.
table MemberSection {
  id:string;
  name:cchat.text.Rich;
  // Total returns the total member count.
  total:int;

  // Asserters
  iconer:Iconer;
  member_dynamic_section:MemberDynamicSection;
}

// MemberDynamicSection represents a dynamically loaded member list section. The
// section behaves similarly to MemberSection, except the information displayed
// will be considered incomplete until LoadMore returns false.
//
// LoadLess can be called by the client to mark chunks as stale, which the
// server can then unsubscribe from.
table MemberDynamicSection (services: "MemberDynamicSectionService") {}

// MemberDynamicSectionService is the service containing call methods for
// implementations of interface MemberDynamicSection.
rpc_service MemberDynamicSectionService {
  // LoadMore is a method which the client can call to ask for more members.
  // This method can do IO.
  //
  // Clients may call this method on the last section in the section slice;
  // however, calling this method on any section is allowed. Clients may not
  // call this method if the number of members in this section is equal to
  // Total.
  LoadMore(LoadMoreParameters):LoadMoreReturns;
  // LoadLess is a method which the client must call after it is done displaying
  // entries that were added from calling LoadMore.
  //
  // The client can call this method exactly as many times as it has called
  // LoadMore. However, false should be returned if the client should stop, and
  // future calls without LoadMore should still return false.
  LoadLess(LoadLessParameters):LoadLessReturns;
}

// LoadMoreParameters is the parameter table for method LoadMore of interface
// MemberDynamicSection.
table LoadMoreParameters {
  call:cchat.call.ID (required);
}

// LoadMoreReturns is the return table for method LoadMore of interface
// MemberDynamicSection.
table LoadMoreReturns {
  call:cchat.call.ID (required);

  bool:bool;
}

// LoadLessParameters is the parameter table for method LoadLess of interface
// MemberDynamicSection.
table LoadLessParameters {
  call:cchat.call.ID (required);
}

// LoadLessReturns is the return table for method LoadLess of interface
// MemberDynamicSection.
table LoadLessReturns {
  call:cchat.call.ID (required);

  bool:bool;
}

// SendableMessage is the bare minimum interface of a sendable message, that is,
// a message that can be sent with SendMessage(). This allows the frontend to
// implement its own message data implementation.
//
// An example of extending this interface is MessageNonce, which is similar to
// IRCv3's labeled response extension or Discord's nonces. The frontend could
// implement this interface and check if incoming MessageCreate events implement
// the same interface.
table SendableMessage {
  content:string;

  // Asserters
  noncer:Noncer;
  replier:Replier;
  attacher:Attacher;
}

// Replier indicates that the message being sent is a reply to something.
// Frontends that support replies can assume that all messages in a Sender can
// be replied to, and the backend can choose to do nothing to the replied ID.
table Replier {
  replying_to:string;
}

// Attacher adds attachments into the message being sent.
table Attacher {
  attachments:[MessageAttachment];
}
